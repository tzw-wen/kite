#!/usr/bin/env python

'''

This script will merge multiple .sqt files, or multiple directories of .sqt
files.  This is primarily useful when the files are all from SEQUEST runs on
the same spectra, but with differing modifications.  In this case, the
unmodified .sqt file or directory should be given first.  (Some fields must be
guessed, and these will be pulled from the first argument.)

Modification symbols can also be appropriately remapped.

When directory arguments are given, a merged .sqt file will be created for
each .sqt filename that exists in the first directory.
'''


# TO DO: Add a check that all input files are using the same static
# mods.  (If not, output is garbage.)



__version__ = "$Id: sqt-merge,v 1.14 2008/08/15 19:19:41 mkc Exp $"

import optparse
import os
import os.path
from pprint import pprint, pformat
import re
import sets
import string
import sys
import types

from groupby import *


def warn(s):
    print >> sys.stderr, 'warning:', s
def error(s):
    sys.exit('error: ' + s)

def flatten(l):
    '''Yield input with tuples and lists flattened.
    (not safe for cyclic structures)
    '''
    if isinstance(l, (types.ListType, types.TupleType)):
        for e in l:
            for r in flatten(e):
                yield r
    else:
        yield l

def stable_m_fields(g):
    '''Return the stable fields of an M record, suitable for comparison'''
    return [ g[i] for i in (0,3,5,6,7,8,9) ]

def typify_m_record(m):
    return [ t(f) for t,f in
             zip((str,int,int,float,float,float,float,int,int,str,str), m) ]

def process_group(options, descriptor, group):
    '''
    Yields the fixed up S, M and L lines for this group.
    '''
## NB: only the "observed M+H+" and "total intensity" fields need actually be
##     identical
#     unique_section_headers = [ k for k, g in groupby(group, lambda x: x[0]) ]
#     if len(unique_section_headers) > 1:
#         warn('non-identical S stats for %s' % (descriptor,))
    yield group[0][0]

    d = [ m.split(None, 10) for m in flatten([ g[1:] for g in group ]) ]
    if not d:
        return                          # no M/L lines
    seqfield = 9
    d = [ g for k, g in groupby(d, lambda x: x[seqfield]) ]

## NB: sequest itself is numerically unstable, so floats cannot be compared w
#      '='; do delta comparison instead
#     # if there are multiple M's w same seq, check them
#     for g in d:
#         for g1 in g[1:]:
#             if stable_m_fields(g1) != stable_m_fields(g[0]):
#                 warn('non-identical M stats for %s (%s)'
#                      % (descriptor, g1[seqfield]))
#                 warn('detail: %s != %s' % (stable_m_fields(g1), stable_m_fields(g[0])))
    # choose one M for each seq
    d = [ typify_m_record(x[0]) for x in d ]

    deltacnfield = 4
    xcorrfield = 5
    spfield = 6

    # find the best (largest) sp value
    d.sort(lambda x,y: -cmp(x[spfield], y[spfield]))
    bestsp = d[0][spfield]
    # find the best (largest) xcorr value
    d.sort(lambda x,y: -cmp(x[xcorrfield], y[xcorrfield]))
    bestxcorr = d[0][xcorrfield]
    if bestxcorr == 0.0:
        # happens frequently, so don't bother warning
        #warn('best XCorr was 0.0 for %s' % (descriptor,))
        bestxcorr = 1.0e-50             # avoid div-by-zero below

    # now output M (and L) records in correct order, including top 5 by XCorr
    # and top 1 by Sp rank
    rank = 0
    lastxcorr = None
    mintoyield = options.best_result_count
    for m in d:
        if m[xcorrfield] != lastxcorr:
            rank += 1
            lastxcorr = m[xcorrfield]
        if mintoyield > 0 or m[spfield] == bestsp:
            m[deltacnfield] = (bestxcorr - m[xcorrfield]) / bestxcorr
            if mintoyield > 0:
                m[1] = rank
            if m[spfield] == bestsp:
                m[2] = 1                    # should already be 1?
            yield '%s\t%d\t%d\t%.3f\t%.4f\t%.4f\t%.1f\t%d\t%d\t%s\t%s' % tuple(m)
            mintoyield -= 1


def fixup_mod_symbols(epsilon, modmap, header, body):
    '''Using modmap and header, switch the mod symbols in body and return it.
    The 'diff_search_options' lines in header indicate current symbol usage,
    and modmap indicates the desired usage.  (Assume that body contains no
    three-character sequences of the form '\x01.\x02'.)
    '''
    assert not re.search(r'\x01.\x02', body), \
           "oops, input had unexpected control characters"
    substmap = {}
    # first determine substs, ex: '*' -> '~' (identity subst okay)
    for h in [ l for l in header.split('\n')
               if re.search(r'(?i)^H\s+DiffMod\s+', l) ]:
        # the '\+?' is to account for an old sqt_header.py bug
        m = re.match(r'(?i)^H\s+DiffMod\s+([A-Z]+)\s*(\S)\s*=\s*\+?(\S+)', h)
        if not m:
            warn('skipping malformed header line: %s' % h)
            continue
        aminos = sets.ImmutableSet(m.group(1))
        symbol = m.group(2)
        weight = float(m.group(3))
        equivs = [ modmap[(weight0, aminos0)] for weight0, aminos0 in modmap
                   if abs(weight0 - weight) <= epsilon and aminos0 >= aminos ]
        if not equivs:
            error('no proper mapping in --mod-map file for %s %s (%s)\n%s'
                  % (weight, aminos, epsilon, pformat(modmap)))
        assert len(equivs) == 1, str((equivs, weight, aminos, modmap))

        if substmap.setdefault(symbol, equivs[0]) != equivs[0]:
            error("multiple inconsistent DiffMod lines for same symbol '%s'"
                  % symbol)

    # now do subst in two steps, avoiding collisions (!)
    # first subst with markers
    #   ex: '*' -> '\x01#\x02'
    for c0, c1 in substmap.items():
        #marked_c1 = '\x01%s\x02' % c1
        #unmarked_c0 = r'[^\x01]%s[^\x02]' % c0
        #         body = re.sub(r'(?m)^(M(\s+\S+){8}\s+)(\S+)',
        #                       lambda m,c0=c0,marked_c1=marked_c1: \
        #                           m.group(1) + m.group(3).replace(c0, marked_c1),
        #                       body)

        # This could be done more gracefully with a recursive call to re.sub,
        # but that might be buggy in Python, currently
        def mark(match, c0=c0, c1=c1):
            seq = match.group(3)
            i = 1
            while 1:
                if i >= len(seq):
                    break
                if (seq[i-1] != '\x01' and seq[i] == c0
                    and seq[i+1:i+2] != '\x02'):
                    seq = seq[:i] + '\x01' + c1 + '\x02' + seq[i+1:]
                    i += 1
                i += 1
            return match.group(1) + seq
        body = re.sub(r'(?m)^(M(\s+\S+){8}\s+)(\S+)', mark, body)
    # then delete the markers
    #   ex: '\x01#\x02' -> '#'
    return re.sub(r'(?m)\x01(.)\x02', r'\1', body)

def process_one_fileset(options, filenames, modmap, outstream):
    '''Merge the files in the filenames tuple, fixing mods per modmap; output
    to outstream.
    '''
    headers = []
    sections = []
    missing_files = set()

    for f in filenames:
        if not os.path.exists(f):
            missing_files.add(f)
            warn("file '%s' is not present (skipping)" % f)
            continue

        fb = file(f).read()
        try:
            # note header lacks final newline
            header, body = re.split(r'\n(?=S)', fb, 1)
        except ValueError:
            header, body = fb, ''
        if not header:
            error("malformed file '%s' (no headers?)" % f)
        if header[0] == 'S':
            header, body = '', fb

        headers.append(header)
        if not body:
            error("malformed file '%s' (no spectra?)" % f)
        if body[0] != 'S':
            error("malformed file '%s' (garbage preceding initial 'S'"
                  " line)" % f)
        if modmap:
            body = fixup_mod_symbols(options.tolerance, modmap, header, body)
        # kill final '\n' so all sections will lack it after split
        sections.extend(re.split(r'\n(?=S)', body.rstrip()))

    sections = [ re.split(r'\n(?=M)', s) for s in sections ]

    def extract_begin_end_charge(section):
        try:
            return tuple([ int(n) for n in section[0].split(None,4)[1:4] ])
        except ValueError, e:
            error("malformed input file [%s]\n\t%s" % (e, section))

    section_groups = groupby_ordered(sections, extract_begin_end_charge)

    print >> outstream, 'H\tComment sqt-merge of files:'
    for f in filenames:
        if f in missing_files:
            print >> outstream, 'H\tComment\t(absent)\t%s' % f
        else:
            print >> outstream, 'H\tComment\t\t%s' % f
    diffmods_emitted = False

    # Is placing this here elegant or ugly?
    def emit_diffmod(modmap):
        '''Emit lines like "H	DiffMod KS#=+14.0" for modmap.'''
        mapitems = modmap.items()
        mapitems.sort(lambda x,y: cmp(x[0][0],y[0][0]))
        for (weight, aminos), symbol in mapitems:
            print >> outstream, 'H\tDiffMod\t%s%s=%+f' \
                  % (''.join(list(aminos)), symbol, weight)

    for h in headers[0].split('\n'):
        if not h:
            continue
        if re.search(r'(?i)^H\s+DiffMod\s+', h):
            if not diffmods_emitted:
                emit_diffmod(modmap)
                diffmods_emitted = True
        else:
            print >> outstream, h
    if not diffmods_emitted:
        emit_diffmod(modmap)

    scanseen = {}
    for g in section_groups:
        descriptor = g[0]
        scanbegin, scanend, charge = descriptor[:3]
        assert charge >= 0
        if scanbegin <= scanseen.get(charge, -1):
            error("overlapping scan numbers detected! (%s,%s,%s)"
                  % (scanbegin, charge, scanseen))
        scanseen[charge] = scanend
        for line in process_group(options, descriptor, g[1]):
            print >> outstream, line



def main():
    parser = optparse.OptionParser(usage=
                                   "usage: %prog [options] "
                                   "<unmodified-sqt-file> <other-sqt-file>..."
                                   "\n"
                                   "       %prog --output=<dir> [options] "
                                   "<unmodified-sqt-dir> <other-sqt-dir>...",
                                   description=__doc__)
    parser.add_option("-m", "--mod-map", dest="modmap",
                      help="map modification symbols using 'dm_standard' lines"
                      " from this file; defaults to none for file args and to"
                      " 'sequest.params' in the --output directory for"
                      " directory args",
                      metavar="FILE")
    EPSILON = 0.000000001
    parser.add_option("-t", "--tolerance", dest="tolerance", type="float",
                      default=EPSILON,
                      help=("deltas within this value are considered to be"
                      " identical, for remapping purposes [default=%s]"
                      % EPSILON), metavar="EPSILON")
    parser.add_option("-b", "--best-result-count", dest="best_result_count",
                      type="int", default=5,
                      help="number of results to keep for each match"
                      " [default=5]", metavar="COUNT")
    parser.add_option("-o", "--output", dest="output",
                      help="output file or directory; defaults to stdout for"
                      " file args and is required for directory args",
                      metavar="PATH")
    (options, args) = parser.parse_args()
    if len(args) < 1 or options.best_result_count < 1:
        parser.print_help()
        sys.exit(1)

    if not (0 <= options.tolerance <= 0.2):
        error("tolerance must be non-negative and less than 0.2")

    for p in args:
        if not os.path.exists(p):
            error("'%s' does not exist" % p)
    directory_mode = os.path.isdir(args[0])
    if [ x for x in args if os.path.isdir(x) != directory_mode ]:
        error("cannot mix file and directory arguments")
    if directory_mode and not options.output:
        error("--output option required when arguments are directories")
    if directory_mode and not os.path.exists(options.output):
        error("%s does not exist" % options.output)
    if directory_mode != bool(options.output
                              and os.path.isdir(options.output)):
        error("--output cannot be file when arguments are directories,"
              " and vice versa")
    if directory_mode:
        for d in args:
            if os.path.samefile(d, options.output):
                error("output directory cannot be the same as input directory"
                      " '%s'" % d)
    if directory_mode and not options.modmap:
        options.modmap = os.path.join(options.output, 'sequest.params')
    if options.modmap and not os.path.isfile(options.modmap):
        error("'%s' does not exist (or is a directory)" % options.modmap)

    modsymmap = {}                      # ex: '#' -> 14.0
    modaaweightset = sets.Set()         # ex: ('K', 14.0)
    modmap = {}                         # ex: (14.0, {'K','S'}) -> '#'
    if options.modmap:
        for l in file(options.modmap):
            if l.startswith('dm_standard'):
                fields = l.split()
                if len(fields) < 4:
                    error("dm_standard line in %s has too few fields"
                          % options.modmap)
                symbol = fields[1]
                weight = float(fields[2])
                aminos = sets.ImmutableSet(fields[3])

                if symbol not in '!#$%&()*+,/:;?@[]^_`{|}~' "'" '0123456789<=>':
                    # just guessing as to what's safe; '-.="' definitely bad
                    warn("dm_standard line in %s uses an unsafe symbol '%s'"
                         "--havoc may result" % (options.modmap, symbol))
                if symbol in '<&>':
                    # DTASelect doesn't escape these
                    warn("dm_standard line in %s uses symbol '%s'"
                         " that DTASelect doesn't properly escape"
                         "--HTML output will be broken" % (options.modmap, symbol))
                if modsymmap.setdefault(symbol, weight) != weight:
                    # required for show/SpectrumApplet correctness
                    error("dm_standard line in %s has multiple weights"
                          " for symbol '%s'" % (options.modmap, symbol))
                if not aminos <= sets.ImmutableSet(string.ascii_uppercase):
                    error("dm_standard line in %s has invalid amino acid"
                          % options.modmap)
                for amino in aminos:
                    if (amino, weight) in modaaweightset:
                        error("dm_standard line in %s maps %s, %s to multiple"
                              " symbols" % (options.modmap, amino, weight))
                    modaaweightset.add((amino, weight))
                modmap[(weight, aminos)] = symbol
    del modsymmap, modaaweightset       # just used for warnings

    if not directory_mode:
        if options.output:
            outstream = file(options.output, 'w')
        else:
            outstream = sys.stdout
        process_one_fileset(options, args, modmap, outstream)
        return

    basenames = [ os.path.basename(fn)
                  for fn in os.listdir(args[0]) if fn.endswith('.sqt') ]
    for b in basenames:
        for d in args[1:]:
            fn = os.path.join(d, b)
            if (os.path.exists(fn)
                and (not os.path.isfile(fn) or not os.path.getsize(fn))):
                error("file '%s' exists, but is not a plain file or is empty"
                      % fn)
    for b in basenames:
        fns = [ os.path.join(d, b) for d in args ]
        process_one_fileset(options, fns, modmap,
                            file(os.path.join(options.output, b), 'w'))


if __name__ == '__main__':
    main()
